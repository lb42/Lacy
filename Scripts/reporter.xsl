<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:t="http://www.tei-c.org/ns/1.0"
     exclude-result-prefixes="xs t  " version="2.0">
    <xsl:output method="html"/>

   <!-- <xsl:param name="corpus">XXX</xsl:param>
    --><!-- the language code -->

    <xsl:param name="webRoot">https://lb42.github.io/Lacy</xsl:param>
    <!-- target website -->

    <xsl:param name="repoRoot">/home/lou/Public/Lacy</xsl:param>
    <!-- source files -->
 
    <xsl:param name="gitRoot">https://raw.githubusercontent.com/lb42/Lacy/main/TEI/</xsl:param>
    <!-- git home of the source files -->

   
    <!-- these two files are generated by refresh.py -->

    <xsl:variable name="driverFile">
        <xsl:value-of select="concat($repoRoot, '/driver.tei')"/>
    </xsl:variable>
    <xsl:variable name="fileNameFile">
        <xsl:value-of select="concat($repoRoot, '/fileNames.xml')"/>
    </xsl:variable>

    <xsl:template match="/">

        <xsl:message>Processing driver file <xsl:value-of select="$driverFile"/></xsl:message>

        <xsl:text disable-output-escaping="yes">&lt;!DOCTYPE html></xsl:text>
        <html>
            <head>
                <meta http-equiv="Content-Type" content="text/html"/>
                <link rel="stylesheet" type="text/css"
                    href="https://distantreading.github.io/css/eltec-styler.css"/>
                <title>
                    <xsl:text>Lacys Acting Edition</xsl:text>
                </title>
            </head>
            <body>
                <xsl:variable name="today">
                    <xsl:value-of
                        select="
                            format-date(current-date(),
                            '[Y0001]-[M01]-[D01]')"
                    />
                </xsl:variable>
                <xsl:variable name="textCount">
                    <xsl:value-of select="count(//t:text)"/>
                </xsl:variable>
                <xsl:variable name="wordCount">
                    <xsl:value-of select="format-number(sum(//t:measure[@type = 'txWords']/@quantity), '#')"/>
                </xsl:variable>
                <xsl:variable name="status">
                    <xsl:text>On </xsl:text>
                    <xsl:value-of select="$today"/>
                      <xsl:text> LAE-TEI contains </xsl:text>
                    <xsl:value-of select="$textCount"/>
                    <xsl:text> texts containing </xsl:text>
                    <xsl:value-of select="$wordCount"/>
                    <xsl:text> words</xsl:text>
                </xsl:variable>
<xsl:message><xsl:value-of select="$status"/></xsl:message>
                  
                <p class="explain">Click on a column heading to sort. Click on a text identifier to
                    read the text (may not work in older browsers).</p>
                <table class="catalogue" id="theTable">
                    <tr class="label">
                        <th onclick="sortTable(0)">Identifier</th>
                        <th onclick="sortTable(1)">Vol.no</th>
                        <th onclick="sortTableNumerically(2)">Page count</th>
                        <th onclick="sortTableNumerically(3)">Word count</th>
                        <th onclick="sortTableNumerically(4)">Spoken word count</th>
                        <th onclick="sortTable(5)">Date</th>
                        <th onclick="sortTable(6)">First Performance</th>
                        <th onclick="sortTable(7)">Title</th>
                        <th onclick="sortTable(8)">Author</th>
                        <th onclick="sortTable(9)">Class codes</th>
                        <th onclick="sortTable(10)">Genre</th>
                    </tr>

                    <!-- Create index file containing details from the header of each text in the driver file -->

                    <xsl:for-each select="t:TEI/t:TEI/t:teiHeader/t:fileDesc">
<!--
                        <xsl:sort select="parent::t:TEI/@xml:id"/>
-->
                        <xsl:variable name="textID" select="parent::t:teiHeader/parent::t:TEI/@xml:id">
                 <!--  <xsl:choose>      
                    <xsl:when test="t:publicationStmt/t:idno"> 
                     <xsl:value-of select="t:publicationStmt/t:idno"/></xsl:when>
                    <xsl:otherwise>
                     <xsl:value-of select="parent::t:teiHeader/parent::t:TEI/@xml:id"/>
                    </xsl:otherwise>
              </xsl:choose>          --></xsl:variable>
                        
                     <xsl:variable name="thisOne" select="."/>
                     
                        <!-- this is the dummy HTML file used by CETEICEAN -->
                        <xsl:variable name="targetFileName">
                            <xsl:value-of select="concat($webRoot, '/', $textID, '.html')"
                            />
                        </xsl:variable>
                        <!-- this is  the xml source in the git repo -->
                        <xsl:variable name="sourceFile">
                            <xsl:value-of
                             select="concat($gitRoot, '/', $textID, '.xml')"/>
                        </xsl:variable>
                        <!-- and off we go -->
                        <tr>
                            <xsl:variable name="wc">
  <xsl:value-of select="$thisOne//t:extent/t:measure[@type = 'txWords']/@quantity"/>                                             
                            </xsl:variable>
                            <xsl:variable name="pc">
                             <xsl:value-of select="$thisOne//t:extent/t:measure[@type = 'pp']/@quantity"/>                        </xsl:variable>
                            <xsl:variable name="date"  
                             select="$thisOne/t:sourceDesc/t:bibl[@type = 'source']/t:eventName/@notAfter"  />
 <!--                               <xsl:message><xsl:value-of select="concat($textID, ' ', $wc, ' ', $pc, ' ', $date)"/>
                                </xsl:message>   
-->    
                            <td>
                                <a>
                                    <xsl:attribute name="href">
                                        <xsl:value-of
                                            select="concat($textID, '.html')"/>
                                    </xsl:attribute>
                                    <xsl:value-of select="$textID"/>
                                </a>

                                <a>
                                    <xsl:attribute name="href">
                                        <xsl:value-of
                                         select="concat($gitRoot,  $textID, '.xml')"
                                        />
                                    </xsl:attribute>
                                    <img src="media/teiLogo.jpg"/>
                                </a>
                            </td>
                            <td>
                                <xsl:value-of select="$thisOne//t:bibl[@type='source']/@n"/>
                            </td>
                            <td>
                             <xsl:value-of
                              select="$thisOne//t:bibl[@type='source']/t:extent/t:measure[@type = 'pp']/@quantity"/>
                              
                            </td>
                            <td>
                                <xsl:value-of select="$wc"/>
                            </td>
                         <td><xsl:value-of select="$thisOne//t:bibl[@type='source']/t:extent/t:measure[@type = 'spWords']/@quantity"/>                  
                            </td>
                            <td>
                                <xsl:value-of select="$date"/>  </td>
                            <td><xsl:value-of select="$thisOne/t:sourceDesc/t:bibl[@type = 'source']/t:eventName/t:name[1]"  /></td>

                            <td>
                                
                                        <xsl:value-of
                                            select="$thisOne/t:titleStmt/t:title[1]"
                                        />

                            </td>
                            <td>
                                <xsl:for-each select="$thisOne/t:titleStmt/t:author">
                                    <xsl:value-of select="concat(normalize-space(.), ' ')"/>
                                </xsl:for-each>
                                
                            </td>
                            <td>
                                <xsl:value-of select="following-sibling::t:profileDesc/t:textClass/t:catRef/@target"
                                />
                            </td>
                            <td>
                             <xsl:value-of select="$thisOne/following-sibling::t:profileDesc/t:textClass/t:keywords/t:term"/>
                             
                            </td>

                        </tr>
                    </xsl:for-each>
                </table>

                <!-- magic to sort the columns -->

                <script>
                    function sortTable(n) {
                    var table, rows, switching, i, x, y, shouldSwitch, dir, switchcount = 0;
                    table = document.getElementById("theTable");
                    switching = true;
                    //Set the sorting direction to ascending:
                    dir = "asc"; 
                    /*Make a loop that will continue until
                    no switching has been done:*/
                    while (switching) {
                    //start by saying: no switching is done:
                    switching = false;
                    rows = table.rows;
                    /*Loop through all table rows (except the
                    first, which contains table headers):*/
                    for (i = 1; i &lt; (rows.length - 1); i++) {
                    //start by saying there should be no switching:
                    shouldSwitch = false;
                    /*Get the two elements you want to compare,
                    one from current row and one from the next:*/
                    x = rows[i].getElementsByTagName("td")[n];
                    y = rows[i + 1].getElementsByTagName("td")[n];
                    /*check if the two rows should switch place,
                    based on the direction, asc or desc:*/
                    
                    //if (Number(x.innerHTML) > Number(y.innerHTML)) {
                    //shouldSwitch = true;
                    //break;
                    //}
                    
                    
                    if (dir == "asc") {
                    
                    if (x.innerHTML.toLowerCase() > y.innerHTML.toLowerCase()) {
                    //if so, mark as a switch and break the loop:
                    shouldSwitch= true;
                    break;
                    }
                    } else if (dir == "desc") {
                    if (x.innerHTML.toLowerCase() &lt; y.innerHTML.toLowerCase()) {
                    //if so, mark as a switch and break the loop:
                    shouldSwitch = true;
                    break;
                    }
                    }
                    }
                    if (shouldSwitch) {
                    /*If a switch has been marked, make the switch
                    and mark that a switch has been done:*/
                    rows[i].parentNode.insertBefore(rows[i + 1], rows[i]);
                    switching = true;
                    //Each time a switch is done, increase this count by 1:
                    switchcount ++;      
                    } else {
                    /*If no switching has been done AND the direction is "asc",
                    set the direction to "desc" and run the while loop again.*/
                    if (switchcount == 0 &amp;&amp; dir == "asc") {
                    dir = "desc";
                    switching = true;
                    }
                    }
                    }
                    }
                    function sortTableNumerically(n) {
                    var table, rows, switching, i, x, y, shouldSwitch, dir, switchcount = 0;
                    table = document.getElementById("theTable");
                    switching = true;
                    //Set the sorting direction to ascending:
                    dir = "asc"; 
                    /*Make a loop that will continue until
                    no switching has been done:*/
                    while (switching) {
                    //start by saying: no switching is done:
                    switching = false;
                    rows = table.rows;
                    /*Loop through all table rows (except the
                    first, which contains table headers):*/
                    for (i = 1; i &lt; (rows.length - 1); i++) {
                    //start by saying there should be no switching:
                    shouldSwitch = false;
                    /*Get the two elements you want to compare,
                    one from current row and one from the next:*/
                    x = rows[i].getElementsByTagName("td")[n];
                    y = rows[i + 1].getElementsByTagName("td")[n];
                    /*check if the two rows should switch place,
                    based on the direction, asc or desc:*/
                        if (dir == "asc") {
                    
                    if (Number(x.innerHTML) > Number(y.innerHTML)) {
                    //if so, mark as a switch and break the loop:
                    shouldSwitch= true;
                    break;
                    }
                    } else if (dir == "desc") {
                    if (Number(x.innerHTML) > Number(y.innerHTML)) {
                    //if so, mark as a switch and break the loop:
                    shouldSwitch = true;
                    break;
                    }
                    }
                    }
                    if (shouldSwitch) {
                    /*If a switch has been marked, make the switch
                    and mark that a switch has been done:*/
                    rows[i].parentNode.insertBefore(rows[i + 1], rows[i]);
                    switching = true;
                    //Each time a switch is done, increase this count by 1:
                    switchcount ++;      
                    } else {
                    /*If no switching has been done AND the direction is "asc",
                    set the direction to "desc" and run the while loop again.*/
                    if (switchcount == 0 &amp;&amp; dir == "asc") {
                    dir = "desc";
                    switching = true;
                    }
                    }
                    }
                    }
                </script>
            </body>
        </html>

    </xsl:template>
    <xsl:function name="t:sanitize"> </xsl:function>

    <xsl:function name="t:checkSize">
        <xsl:param name="count" as="xs:integer"/>
        <xsl:param name="code"/>
        <xsl:variable name="actualCode">
            <xsl:choose>
                <xsl:when test="$count lt 50000">short</xsl:when>
                <xsl:when test="$count lt 100000">medium</xsl:when>
                <xsl:when test="$count gt 100000">long</xsl:when>
            </xsl:choose>
        </xsl:variable>
        <xsl:if test="$code ne $actualCode"> !!</xsl:if>
    </xsl:function>

    <xsl:function name="t:showBalance" as="item()*">
        <xsl:param name="nodes"/>
        <xsl:param name="totalVal" as="xs:integer"/>
        <xsl:param name="values" as="xs:string"/>

        <xsl:variable name="target" select="$totalVal div count(tokenize($values, ','))"/>
        <!--      <xsl:message>Target is <xsl:value-of select="$target"/></xsl:message>
  -->
        <xsl:for-each select="tokenize($values, ',')">
            <xsl:variable name="val">
                <xsl:value-of select="."/>
            </xsl:variable>
            <xsl:variable name="count">
                <xsl:value-of select="count($nodes[@key = $val])"/>
            </xsl:variable>
            <!--    <xsl:message>... count for <xsl:value-of select="$val"/> is <xsl:value-of select="$count"/></xsl:message>
     -->
            <xsl:choose>
                <xsl:when test="$target &gt; $count">
                    <xsl:value-of select="concat($val, '=', $count, '!')"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="concat($val, '=', $count)"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:for-each>
    </xsl:function>
</xsl:stylesheet>
